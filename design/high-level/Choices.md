# 组件模型高级设计选择

基于[目标](Goals.md)和[用例](UseCases.md)，组件模型做出了几个高级设计选择，这些选择贯穿了整个组件模型。

1. 组件模型采用共享无极架构，其中组件实例完全封装了它们的线性内存、表、全局变量和未来的GC内存。组件接口仅包含不可变的复制值、不透明的类型句柄和不可变的未实例化模块/组件。虽然句柄和导入可以用作间接共享的形式，但[依赖用例](UseCases.md#component-dependencies)使得这种程度的共享可以被精细地控制。

2. 组件模型不引入全局单例、命名空间、注册表、定位器服务或框架，通过这些组件被配置或链接。相反，所有相关的用例都通过组件的显式参数化来解决，通过导入（数据、函数和类型）与每个组件的客户端都可以独立地选择实例化组件与其自己选择的导入值。

3. 组件模型不假设全局的组件间垃圾或循环收集器能够跟踪跨组件循环。相反，资源具有生命周期，并需要通过句柄进行显式的非循环所有权。显式的生命周期允许资源具有确定性的析构函数，并可用于在非垃圾收集语言中释放线性内存分配。

4. 组件模型假设在运行时不可用即时编译，因此仅提供声明性链接功能，支持预编译、优化和分析。虽然组件实例可以在运行时创建，但在执行开始之前已知的组件以及它们的依赖和客户端。另见[这个资料](https://docs.google.com/presentation/d/1PSC3Q5oFsJEaYyV5lNJvVgh-SNxhySWUqZ6puyojMi8/edit#slide=id.gceaf867ebf_0_10)。)
